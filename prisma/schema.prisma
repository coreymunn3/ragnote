generator client {
  provider        = "prisma-client-js"
  previewFeatures = ["postgresqlExtensions"]
}

datasource db {
  provider  = "postgresql"
  url       = env("DATABASE_URL")
  directUrl = env("DIRECT_URL")
  // extensions = [vector(schema: "public")]
}

enum PermissionLevel {
  VIEWER
  EDITOR // V2 feature: Editor permissions, but the enum is here for future-proofing.
}

enum SubscriptionTier {
  FREE
  PRO
}

enum ChatMessageSenderType {
  USER
  AI
}

enum FileType {
  PDF
  DOCX
  IMAGE // For image files like JPG, PNG
  AUDIO // For audio files like MP3, WAV
  // Add other types as needed, e.g., VIDEO, CSV, JSON
}

enum LLMOperationType {
  CHAT_COMPLETION
  TITLE_GENERATION
  EMBEDDING
}

// -----------------------------------------------------------
// Core User & Authentication
// -----------------------------------------------------------
model app_user {
  id                 String   @id @default(uuid()) @db.Uuid
  clerk_id           String   @unique
  username           String?
  email              String   @unique
  first_name         String?
  last_name          String?
  avatar_url         String?
  created_at         DateTime @default(now()) @db.Timestamptz(3)
  updated_at         DateTime @updatedAt @db.Timestamptz(3)
  is_deleted         Boolean  @default(false) // Soft delete to maintain subscription/transaction info
  stripe_customer_id String?  @unique // for paid customers

  folders              folder[]
  notes                note[]
  shared_notes         note_permission[] @relation("NotePermissionsSharedBy") // Notes this user has shared
  notes_shared_with_me note_permission[] @relation("NotePermissionsSharedWith") // Notes shared with this user
  files                file[] // Files uploaded by this user

  subscription  user_subscription? // One-to-one relation
  chat_sessions chat_session[]
  llm_usage_log llm_usage_log[]
}

// -----------------------------------------------------------
// User Subscription 
// -----------------------------------------------------------
model user_subscription {
  id                     String           @id @default(uuid()) @db.Uuid
  user_id                String           @unique @db.Uuid // Each user has at most one subscription
  tier                   SubscriptionTier
  end_date               DateTime?        @db.Timestamptz(3) // Null for active, recurring subscriptions
  stripe_subscription_id String?          @unique // ← Changes with each new subscription
  stripe_price_id        String? // ← Which plan they're on
  created_at             DateTime         @default(now()) @db.Timestamptz(3)
  updated_at             DateTime         @updatedAt @db.Timestamptz(3)

  user app_user @relation(fields: [user_id], references: [id], onDelete: Cascade)

  @@map("user_subscription")
}

// -----------------------------------------------------------
// Folder Structure
// -----------------------------------------------------------
model folder {
  id          String   @id @default(uuid()) @db.Uuid
  user_id     String   @db.Uuid
  folder_name String
  is_deleted  Boolean  @default(false) // Soft delete for V1
  created_at  DateTime @default(now()) @db.Timestamptz(3)
  updated_at  DateTime @updatedAt @db.Timestamptz(3)

  user         app_user       @relation(fields: [user_id], references: [id], onDelete: Cascade)
  notes        note[]
  files        file[]
  chat_session chat_session[]
}

// -----------------------------------------------------------
// Notes & Versioning
// -----------------------------------------------------------
model note {
  id                 String  @id @default(uuid()) @db.Uuid
  user_id            String  @db.Uuid
  folder_id          String? @db.Uuid
  title              String
  current_version_id String? @unique @db.Uuid // Points to the currently published version
  is_pinned          Boolean @default(false)
  is_deleted         Boolean @default(false) // Soft delete for V1

  created_at DateTime @default(now()) @db.Timestamptz(3)
  updated_at DateTime @updatedAt @db.Timestamptz(3)

  user            app_user          @relation(fields: [user_id], references: [id], onDelete: Cascade)
  folder          folder?           @relation(fields: [folder_id], references: [id], onDelete: SetNull)
  versions        note_version[]    @relation("NoteVersions") // All versions of this note
  current_version note_version?     @relation("CurrentNoteVersion", fields: [current_version_id], references: [id], onDelete: SetNull)
  permissions     note_permission[] // Shares related to this note
  chat_session    chat_session[]
}

model note_version {
  id                 String    @id @default(uuid()) @db.Uuid
  note_id            String    @db.Uuid
  version_number     Int       @default(1)
  rich_text_content  Json      @default("[]") @db.Json // rich text content of this version - json for blocknote editor
  plain_text_content String    @default("") // plain text content of this version - for embedding & processing
  is_published       Boolean   @default(false) // False if it's a draft, true if published
  published_at       DateTime? @db.Timestamptz(3) // Null if it's a draft
  created_at         DateTime  @default(now()) @db.Timestamptz(3)
  updated_at         DateTime  @updatedAt @db.Timestamptz(3)

  note               note            @relation("NoteVersions", fields: [note_id], references: [id], onDelete: Cascade)
  chunks             note_chunk[] // Chunks and embeddings for this version
  current_version_of note?           @relation("CurrentNoteVersion")
  llm_usage_log      llm_usage_log[]

  @@index([note_id, is_published, published_at]) // Optimize for retrieving published versions
  @@index([note_id, version_number]) // For fetching specific versions
  @@map("note_version")
}

model note_chunk {
  id              String                      @id @default(uuid()) @db.Uuid
  note_version_id String                      @db.Uuid
  chunk_index     Int
  chunk_text      String
  embedding       Unsupported("vector(1536)")
  metadata        Json?                       @db.JsonB // Stores user_id, note_id, note_title, folder_id for filtering
  created_at      DateTime                    @default(now()) @db.Timestamptz(3)

  note_version note_version @relation(fields: [note_version_id], references: [id], onDelete: Cascade)

  @@index([note_version_id]) // Optimize for retrieving chunks for a specific version
  @@map("note_chunk")
}

// -----------------------------------------------------------
// Note Sharing & Permissions
// -----------------------------------------------------------
model note_permission {
  id                  String          @id @default(uuid()) @db.Uuid
  note_id             String          @db.Uuid
  shared_by_user_id   String          @db.Uuid
  shared_with_user_id String?         @db.Uuid // Null if inviting a non-user by email
  shared_with_email   String? // Email for non-user invitations
  permission_level    PermissionLevel // e.g., VIEWER, EDITOR (V2)
  share_token         String? // Unique token for email invitation link
  // token_expires_at    DateTime?       // Removed for V1 simplicity as discussed
  active              Boolean         @default(true) // For V1, consider simply deleting instead of soft-deactivating
  created_at          DateTime        @default(now()) @db.Timestamptz(3)
  updated_at          DateTime        @updatedAt @db.Timestamptz(3)

  note        note      @relation(fields: [note_id], references: [id], onDelete: Cascade)
  shared_by   app_user  @relation("NotePermissionsSharedBy", fields: [shared_by_user_id], references: [id], onDelete: Cascade)
  shared_with app_user? @relation("NotePermissionsSharedWith", fields: [shared_with_user_id], references: [id], onDelete: Cascade)

  // Uniqueness: For MVP, rely on application logic to prevent duplicate shares
  // (e.g., cannot share same note to same user_id AND cannot share same note to same email)
  // More complex unique constraints or partial indexes in Postgres can handle this later.
  @@map("note_permission")
}

// -----------------------------------------------------------
// File Uploads (for future text/audio extraction)
// -----------------------------------------------------------
model file {
  id          String   @id @default(uuid()) @db.Uuid
  user_id     String   @db.Uuid
  folder_id   String?  @db.Uuid
  file_name   String
  file_type   FileType // e.g., PDF, DOCX, IMAGE, AUDIO
  file_url    String? // URL to cloud storage for the raw file
  is_deleted  Boolean  @default(false) // Soft delete for V1
  uploaded_at DateTime @default(now()) @db.Timestamptz(3)

  user           app_user             @relation(fields: [user_id], references: [id], onDelete: Cascade)
  folder         folder?              @relation(fields: [folder_id], references: [id], onDelete: SetNull)
  content_chunks file_content_chunk[] // Chunks and embeddings for extracted content
}

model file_content_chunk {
  id                 String  @id @default(uuid()) @db.Uuid
  file_id            String  @db.Uuid
  chunk_text         String? // Extracted text (transcription for audio, OCR for images/PDFs)
  audio_url_segment  String? // For audio chunks: URL to specific segment
  image_url_segment  String? // For image chunks: URL to specific crop
  start_time_seconds Float? // For audio/video chunks: start time
  end_time_seconds   Float? // For audio/video chunks: end time

  embedding Unsupported("vector(1536)")

  created_at DateTime @default(now()) @db.Timestamptz(3)

  file file @relation(fields: [file_id], references: [id], onDelete: Cascade)

  @@index([file_id]) // Optimize for retrieving chunks for a specific file
  @@map("file_content_chunk")
}

// -----------------------------------------------------------
// Chat Sessions & Messages 
// -----------------------------------------------------------
model chat_session {
  id         String  @id @default(uuid()) @db.Uuid
  user_id    String  @db.Uuid
  title      String? // Auto-generated title for the conversation
  chat_scope Json    @db.JsonB // JSON structure: { scope: "note"|"folder"|"global", scopeId: string|null, noteVersions: [{noteId, versionId}] }
  is_pinned  Boolean @default(false) // For pinning conversations in UI
  is_deleted Boolean @default(false) // Soft delete for V1
  note_id    String? @db.Uuid // along with the chat_scope this makes it easier to query chat sessions for a note
  folder_id  String? @db.Uuid // along with the chat_scope this makes it easier to query chat sessions for a folder

  created_at DateTime @default(now()) @db.Timestamptz(3)
  updated_at DateTime @updatedAt @db.Timestamptz(3)

  user          app_user        @relation(fields: [user_id], references: [id], onDelete: Cascade)
  messages      chat_message[] // Individual messages within this session
  note          note?           @relation(fields: [note_id], references: [id])
  folder        folder?         @relation(fields: [folder_id], references: [id])
  llm_usage_log llm_usage_log[]

  @@index([user_id, is_deleted]) // Optimize for retrieving user's active/deleted chats
  @@index([user_id, is_pinned]) // Optimize for pinned chats
  @@index([chat_scope]) // Optimize for scope-based queries
  @@map("chat_session")
}

model chat_message {
  id              String                @id @default(uuid()) @db.Uuid
  chat_session_id String                @db.Uuid
  sender_type     ChatMessageSenderType
  content         String
  llm_response    Json? // to store the entire response object coming from the AI which includes object and response metadata like token usage
  llm_sources     Json? // to store the sources that were used in an AI response

  created_at DateTime @default(now()) @db.Timestamptz(3)

  chat_session chat_session    @relation(fields: [chat_session_id], references: [id], onDelete: Cascade)
  llm_usage    llm_usage_log[] // Token usage logs related to this chat message

  @@index([chat_session_id]) // Optimize for retrieving messages for a specific session
  @@map("chat_message")
}

// -----------------------------------------------------------
// LLM Token Usage Tracking
// -----------------------------------------------------------
model llm_usage_log {
  id                String           @id @default(uuid()) @db.Uuid
  user_id           String           @db.Uuid
  model_name        String // "gpt-4o", "gpt-4o-mini", "text-embedding-3-small"
  operation_type    LLMOperationType
  prompt_tokens     Int
  completion_tokens Int? // null for embeddings
  total_tokens      Int

  // Optional associations
  chat_message_id String? @db.Uuid
  chat_session_id String? @db.Uuid
  note_version_id String? @db.Uuid

  created_at DateTime @default(now()) @db.Timestamptz(3)

  user         app_user      @relation(fields: [user_id], references: [id], onDelete: Cascade)
  chat_message chat_message? @relation(fields: [chat_message_id], references: [id], onDelete: SetNull)
  chat_session chat_session? @relation(fields: [chat_session_id], references: [id], onDelete: SetNull)
  note_version note_version? @relation(fields: [note_version_id], references: [id], onDelete: SetNull)

  @@index([user_id, created_at]) // Optimize for user usage queries
  @@index([chat_message_id]) // Optimize for chat-related usage
  @@map("llm_usage_log")
}

// -----------------------------------------------------------
// Webhook Event Processing
// -----------------------------------------------------------

enum WebhookProvider {
  CLERK
  STRIPE
}

model webhook_events {
  id           String          @id @default(uuid()) @db.Uuid
  provider     WebhookProvider
  webhook_id   String
  event_type   String
  processed_at DateTime        @default(now()) @db.Timestamptz(3)

  // unique webhook id's within provider
  @@unique([provider, webhook_id])
}
